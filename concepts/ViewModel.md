## ViewModel

 `ViewModel` 클래스는 관련된 데이터를 수명주기를 고려한 방식으로 저장하고 UI 를 관리하기 위해 설계되었다. `ViewModel` 클래스는 화면 회전과 같은 구성 변경 사항에도 데이터가 그대로 유지된다.

> ★ Note : `ViewModel` 을 안드로이드 프로젝트로 가져오려면 [프로젝트에 구성 요소 추가하기](https://developer.android.com/topic/libraries/architecture/adding-components#lifecycle) 를 참조하면 된다.

 안드로이드 프레임워크는 `Activity` 나 `Fragment` 와 같은 UI 컨트롤러의 수명주기를 관리한다. 프레임 워크는 특정 사용자의 동작 또는 사용자의 제어에서 완전히 벗어난 장치 이벤트에 대한 응답으로 UI 컨트롤러를 파괴하거나 다시 생성할 수 있다.

 시스템이 UI 컨트롤러를 destroy 하거나 다시 생성하면 임시로 저장된 UI 관련 데이터가 사라진다. 예를 들어, 앱에 사용자의 activity 중 하나에 대한 사용자 목록(데이터)이 포함될 수 있다. 구성 변경을 위해 activity 가 재생성 되었을 때, 새로운 activity 가 사용자 목록(데이터)을 다시 가져와야 한다. 단순한 데이터의 경우, activity 는 `onSaveInstanceState()` 메서드를 사용할 수 있고 그 데이터는 `onCreate()` 메서드에서 번들로부터 데이터를 복원할 수 있다. 그러나 이 방법은 _직렬화 된 후 역직렬화될 수 있는(?)_ 작은 데이터에만 적합하며, 사용자 또는 비트맵들의 목록과 같은 잠재적으로 많은 양의 데이터에는 적합하지 않다.

 또 다른 문제점은 UI 컨트롤러가 비동기 호출을 자주 만들어서 반환하는 데 시간이 걸릴 수 있다는 것이다. UI 컨트롤러는 이러한 호출을 관리하고 잠재적인 메모리 누수를 방지하기 위해 시스템이 destroy 된 후 정리해야한다. 이를 위해서는 많은 유지보수가 필요하고, 구성 변경을 위해 객체가 다시 만들어지는 경우 객체는 이미 만든 호출을 다시 재발행 해야하기 때문에 리소스가 낭비된다.

 `Activity` 및 `Fragment` 와 같은 UI 컨트롤러는 주로 UI 데이터를 표시하거나, 사용자 작업에 반응하거나, 권한 요청과 같은 운영 체제 통신을 처리하기 위해 고안되었다. UI 컨트롤러가 데이터베이스 또는 네트워크에서 데이터를 로드하는 작업을 수행하도록 요구하면 클래스에 _bloat(고창증, 부풀게하는것, 부푸는것, 부풀다....)_ 가 추가된다. UI 컨트롤러에 과도한 책임을 할당하면 _(많은 일을 시키면?)_ 앱의 모든 작업을 자체적으로 처리하려는 단일 클래스가 발생할 수 있다. 이런 방법으로 UI 컨트롤러에게 과도한 책임을 할당하면 테스트가 훨씬 더 어려워진다.

 UI 컨트롤러 로직으로부터 _뷰 데이터의 소유권(?)_을 분리하면 더 쉽고 효율적이다.



